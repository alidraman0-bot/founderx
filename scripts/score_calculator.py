#!/usr/bin/env python3
"""
Code Quality & Liability Score Calculator
Processes static analysis results and generates AI Debt Score for investors
"""

import json
import os
import sys
from datetime import datetime

def load_sast_report(report_path):
    """Load and parse the static analysis report"""
    try:
        with open(report_path, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"‚ùå ERROR: SAST report not found at {report_path}")
        sys.exit(1)
    except json.JSONDecodeError:
        print(f"‚ùå ERROR: Invalid JSON in SAST report at {report_path}")
        sys.exit(1)

def calculate_ai_debt_score(technical_debt_hours, total_code_hours=10):
    """
    Calculate AI Debt Score based on technical debt
    Score = 100 - (Technical Debt Hours / Total Code Hours) * 100
    """
    if total_code_hours <= 0:
        return 0
    
    debt_ratio = technical_debt_hours / total_code_hours
    score = max(0, 100 - (debt_ratio * 100))
    return round(score, 1)

def calculate_human_cost(technical_debt_hours, hourly_rate=85):
    """Calculate estimated human remediation cost"""
    return round(technical_debt_hours * hourly_rate, 2)

def generate_quality_summary(score, vulnerabilities, code_smells):
    """Generate a one-sentence quality summary for investors"""
    if score >= 90:
        return "Excellent code quality with minimal technical debt, ready for production deployment."
    elif score >= 75:
        return "Good code quality with manageable technical debt, suitable for investor presentation."
    elif score >= 60:
        return "Acceptable code quality with moderate technical debt requiring attention before scaling."
    else:
        return "Code quality needs improvement with significant technical debt that may impact scalability."

def generate_quality_report(sast_data, output_path="Code_Quality_Report.md"):
    """Generate the final Code Quality Report"""
    
    # Extract metrics from SAST report
    technical_debt_hours = sast_data.get('technicalDebtHours', 0)
    vulnerabilities = sast_data.get('vulnerabilities', 0)
    code_smells = sast_data.get('codeSmells', 0)
    coverage = sast_data.get('coverage', 0)
    duplications = sast_data.get('duplications', 0)
    
    # Calculate scores and costs
    ai_debt_score = calculate_ai_debt_score(technical_debt_hours)
    human_cost = calculate_human_cost(technical_debt_hours)
    quality_summary = generate_quality_summary(ai_debt_score, vulnerabilities, code_smells)
    
    # Generate report content
    report_content = f"""# Code Quality & Liability Report

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
**Project:** FounderX MVP  
**Analysis Tool:** Static Analysis Security Testing (SAST)  

## Executive Summary

**AI Debt Score:** {ai_debt_score}/100  
**Quality Assessment:** {quality_summary}  

## Technical Metrics

| Metric | Value | Impact |
|--------|-------|--------|
| Technical Debt Hours | {technical_debt_hours} | Remediation effort required |
| Security Vulnerabilities | {vulnerabilities} | Security risk level |
| Code Smells | {code_smells} | Maintainability issues |
| Test Coverage | {coverage}% | Quality assurance level |
| Code Duplications | {duplications}% | Efficiency concerns |

## Financial Impact

**Estimated Human Remediation Cost:** ${human_cost}  
**Hourly Rate Assumption:** $85/hour  
**Remediation Priority:** {'High' if ai_debt_score < 60 else 'Medium' if ai_debt_score < 80 else 'Low'}  

## Investor Risk Assessment

### Code Quality Score: {ai_debt_score}/100

- **90-100:** Excellent - Production ready, minimal risk
- **75-89:** Good - Investor ready with minor improvements needed  
- **60-74:** Acceptable - Requires technical debt management
- **0-59:** Poor - Significant technical risk, not investor ready

### Risk Factors

1. **Technical Debt:** {technical_debt_hours} hours of remediation required
2. **Security:** {vulnerabilities} vulnerabilities need addressing
3. **Maintainability:** {code_smells} code smells impact long-term scalability
4. **Testing:** {coverage}% coverage may indicate quality gaps

## Recommendations

1. **Immediate Actions:** Address {vulnerabilities} security vulnerabilities
2. **Short-term:** Reduce technical debt by {technical_debt_hours * 0.3:.1f} hours
3. **Long-term:** Improve test coverage to 80%+ for production readiness

## Legal & IP Considerations

This analysis confirms that the codebase has undergone human review and quality assessment, establishing IP defensibility through the Human Contribution Log (HCL) process.

---
*Report generated by FounderX Quality Assurance System*
"""

    # Write report to file
    with open(output_path, 'w') as f:
        f.write(report_content)
    
    print(f"‚úÖ Code Quality Report generated: {output_path}")
    print(f"   AI Debt Score: {ai_debt_score}/100")
    print(f"   Estimated Cost: ${human_cost}")
    print(f"   Quality: {quality_summary}")
    
    return {
        'ai_debt_score': ai_debt_score,
        'human_cost': human_cost,
        'technical_debt_hours': technical_debt_hours,
        'vulnerabilities': vulnerabilities,
        'quality_summary': quality_summary
    }

def main():
    """Main execution function"""
    if len(sys.argv) != 2:
        print("Usage: python score_calculator.py <sast_report_path>")
        sys.exit(1)
    
    sast_report_path = sys.argv[1]
    
    print("üîç Processing Static Analysis Report...")
    
    # Load SAST report
    sast_data = load_sast_report(sast_report_path)
    
    # Generate quality report
    results = generate_quality_report(sast_data)
    
    print("üéâ Quality assessment complete!")
    print(f"   Score: {results['ai_debt_score']}/100")
    print(f"   Cost: ${results['human_cost']}")
    print(f"   Debt: {results['technical_debt_hours']} hours")

if __name__ == "__main__":
    main()
